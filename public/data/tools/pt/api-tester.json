{"p2":"Enter the API endpoint URL you want to test in the URL field. Select the HTTP method from the dropdown (GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS). Add custom headers using the key-value inputs—common headers like Content-Type and Authorization can be added. For methods that support a request body (POST, PUT, PATCH), enter your JSON, XML, or form data in the body field. Click send request, and the tool displays the response status code, headers, and body. Response time is measured and displayed. The entire request is made from your browser using the Fetch API.","p3":"Frontend developers test backend APIs during development without writing test scripts or using Postman. API integrators verify third-party API endpoints and debug authentication issues. DevOps engineers check API health endpoints and response times during deployment. Security testers send crafted requests to APIs to test input validation and error handling. Mobile app developers test REST APIs before implementing native HTTP clients. Students learning web development experiment with public APIs to understand HTTP methods and status codes.","p4":"For authenticated APIs, add your Bearer token or API key in the Authorization header—never hardcode credentials in client-side code for production. When testing POST/PUT with JSON, set Content-Type: application/json or the server may reject your request. Check CORS headers if requests fail from the browser—the API must allow your origin. Use OPTIONS method to verify supported HTTP methods before testing. For debugging, examine both request and response headers, not just the body. Response status codes in the 400s indicate client errors (bad request), while 500s indicate server errors.","p5":"The tool uses the Fetch API to make HTTP requests with the specified method, headers, and body. Requests are cross-origin and subject to CORS restrictions imposed by the target server. Headers are sent as a Headers object constructed from the key-value pairs. Request body is sent as-is for POST/PUT/PATCH methods. Response status, headers, and body are extracted from the Response object. Body content is read as text using response.text() and displayed in the interface. Response time is measured using performance.now() before and after the fetch operation."}