{"p2":"Paste your JSON document into the data panel and enter a JSONPath expression in the query field. Expressions use dot notation ($.store.book[0].title) or bracket notation with filters ($.store.book[?(@.price < 10)]). The tool evaluates the path against your data and displays all matching values with their locations. Syntax highlighting helps identify errors in complex paths. Advanced features include wildcard operators ($.store.book[*].author) and recursive descent ($..*). All querying happens in-browser without server round-trips.","p3":"Backend engineers test JSONPath expressions before implementing them in API response filters or database queries. Data analysts extract specific metrics from large JSON logs without writing custom parsing scripts. QA testers validate that API responses contain expected values at the correct paths. DevOps teams query configuration files stored as JSON to verify settings across multiple environments without manually traversing nested structures.","p4":"Start with simple paths and add complexity incrementally—debugging $..book[?(@.price)] is easier than troubleshooting a 50-character expression. Use filter expressions with @.property to navigate arrays based on conditions, but remember they can be slower on large datasets. The recursive descent operator (..) is powerful but returns everything matching a key name—combine it with filters for precision. Bracket notation is essential when keys contain special characters or spaces. Test your paths on sample data before deploying them in production code."}