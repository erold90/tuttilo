{"p2":"Collez votre document JSON dans le panneau de données et entrez une expression JSONPath dans le champ de requête. Les expressions utilisent la notation par points ($.store.book[0].title) ou la notation entre crochets avec filtres ($.store.book[?(@.price < 10)]). L'outil évalue le chemin par rapport à vos données et affiche toutes les valeurs correspondantes avec leurs emplacements. La coloration syntaxique aide à identifier les erreurs dans les chemins complexes. Les fonctionnalités avancées incluent les opérateurs génériques ($.store.book[*].author) et la descente récursive ($..*). Toutes les requêtes se font dans le navigateur sans aller-retours serveur.","p3":"Les ingénieurs backend testent les expressions JSONPath avant de les implémenter dans les filtres de réponse d'API ou les requêtes de base de données. Les analystes de données extraient des métriques spécifiques de gros logs JSON sans écrire de scripts d'analyse personnalisés. Les testeurs QA valident que les réponses d'API contiennent les valeurs attendues aux chemins corrects. Les équipes DevOps interrogent les fichiers de configuration stockés en JSON pour vérifier les paramètres à travers plusieurs environnements sans parcourir manuellement les structures imbriquées.","p4":"Commencez par des chemins simples et ajoutez de la complexité progressivement—déboguer $..book[?(@.price)] est plus facile que dépanner une expression de 50 caractères. Utilisez les expressions de filtre avec @.property pour naviguer dans les tableaux basés sur des conditions, mais rappelez-vous qu'elles peuvent être plus lentes sur de gros jeux de données. L'opérateur de descente récursive (..) est puissant mais renvoie tout ce qui correspond à un nom de clé—combinez-le avec des filtres pour la précision. La notation entre crochets est essentielle lorsque les clés contiennent des caractères spéciaux ou des espaces. Testez vos chemins sur des données d'exemple avant de les déployer dans le code de production."}