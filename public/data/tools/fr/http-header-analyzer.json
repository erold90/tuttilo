{"p2":"Copy HTTP response headers from your browser's developer tools (Network tab) or from a curl command output. Paste the raw header text into the input area—include both the header names and values, one per line. Click analyze, and the tool parses each header, identifies its category (caching, security, CORS, content type, etc.), and provides a brief explanation of what it does. Security headers like CSP, HSTS, and X-Frame-Options are highlighted with their configuration details. The analysis helps you understand server configuration and identify missing security headers.","p3":"Security engineers audit website security posture by checking for missing or misconfigured security headers. Frontend developers debug CORS issues by examining Access-Control headers from API responses. Performance engineers analyze caching headers to optimize CDN and browser cache behavior. DevOps teams verify correct header configuration after deploying new web servers or proxies. Penetration testers identify security weaknesses like missing CSP or permissive CORS policies. Students learning web security understand how headers affect browser behavior and security policies.","p4":"Security headers like Content-Security-Policy can break functionality if misconfigured—test thoroughly in staging before production. The order of headers generally doesn't matter, but some proxies or servers may behave unexpectedly. Missing Strict-Transport-Security leaves users vulnerable to SSL-stripping attacks—add it immediately on HTTPS sites. Permissive CORS headers (Access-Control-Allow-Origin: *) should never be used with credentials. Check Cache-Control on dynamic content to prevent browsers from caching personalized or sensitive data. X-Frame-Options and CSP frame-ancestors both control iframe embedding—ensure they don't conflict."}