#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import json

with open('/tmp/de_blog_part3.json', 'r', encoding='utf-8') as f:
    de = json.load(f)

# 13. json-vs-xml-vs-yaml
de["json-vs-xml-vs-yaml"] = {
    "s1": {
        "h": "\u00dcberblick \u00fcber Datenserialisierungsformate",
        "p": "JSON, XML und YAML sind Datenserialisierungsformate, die zum Strukturieren, Speichern und \u00dcbertragen von Informationen zwischen Systemen verwendet werden. Serialisierung wandelt Datenstrukturen in Formate um, die in Dateien gespeichert oder \u00fcber Netzwerke gesendet werden k\u00f6nnen und dann wieder in nutzbare Datenstrukturen deserialisiert werden.\n\nJSON (JavaScript Object Notation) entstand in den fr\u00fchen 2000er Jahren als leichtgewichtige Alternative zu XML. XML (Extensible Markup Language) ist seit 1998 ein Industriestandard. YAML (YAML Ain't Markup Language) wurde 2001 mit Fokus auf menschliche Lesbarkeit eingef\u00fchrt. Jedes Format hat eine eigene Syntax, St\u00e4rken und ideale Anwendungsf\u00e4lle. Ihre Wahl beeinflusst Entwicklungsgeschwindigkeit, Performance, Dateigr\u00f6\u00dfe und Wartbarkeit. Das Verst\u00e4ndnis ihrer Unterschiede hilft Ihnen, das richtige Format f\u00fcr APIs, Konfigurationsdateien, Datenaustausch und Dokumentation zu w\u00e4hlen."
    },
    "s2": {
        "h": "JSON: Standard f\u00fcr Web-APIs",
        "p": "JSON verwendet eine einfache Schl\u00fcssel-Wert-Paar-Syntax mit geschweiften Klammern f\u00fcr Objekte und eckigen Klammern f\u00fcr Arrays. Es unterst\u00fctzt Strings, Zahlen, Booleans, null, Arrays und verschachtelte Objekte. JSON ist nativ in JavaScript, was es zur nat\u00fcrlichen Wahl f\u00fcr Webanwendungen und REST-APIs macht. Beispiel: {\"name\": \"Hans\", \"age\": 30, \"active\": true}.\n\nZu den Vorteilen von JSON z\u00e4hlen kompakte Dateigr\u00f6\u00dfe, schnelles Parsing und universelle Sprachunterst\u00fctzung durch Bibliotheken. Es ist sowohl f\u00fcr Menschen als auch f\u00fcr Maschinen leicht zu lesen und zu schreiben. JSON ist der Standard f\u00fcr moderne Web-APIs, mobile Apps und NoSQL-Datenbanken wie MongoDB. Das Format ist streng bei der Syntax \u2013 keine Kommentare, nachgestellte Kommata oder nicht-zitierte Schl\u00fcssel \u2013 was Mehrdeutigkeit reduziert, aber die manuelle Bearbeitung weniger nachsichtig macht. JSONs Einfachheit macht es ideal, wenn leichtgewichtiger Datenaustausch mit minimalem Overhead ben\u00f6tigt wird. Tools wie Tuttilos JSON-Formatierer helfen beim Validieren und Formatieren von JSON f\u00fcr bessere Lesbarkeit."
    },
    "s3": {
        "h": "XML: Enterprise und Legacy-Systeme",
        "p": "XML verwendet eine Tag-basierte Syntax \u00e4hnlich HTML, mit \u00f6ffnenden und schlie\u00dfenden Tags, die Daten umschlie\u00dfen. Es unterst\u00fctzt Attribute, Namespaces und komplexe Schemata f\u00fcr Datenvalidierung. XML ist ausf\u00fchrlicher als JSON: <person><name>Hans</name><age>30</age></person> repr\u00e4sentiert dieselben Daten wie das obige JSON-Beispiel.\n\nDie St\u00e4rken von XML umfassen leistungsf\u00e4hige Schema-Validierung (XSD), XSLT-Transformationen zur Konvertierung zwischen Formaten und XPath f\u00fcr Datenabfragen. Es ist selbstdokumentierend mit Metadaten durch Attribute und unterst\u00fctzt gemischten Inhalt (Text und Tags zusammen), was es f\u00fcr dokumentenorientierte Daten geeignet macht. XML dominiert in Enterprise-Systemen, SOAP-Webservices, Konfigurationsdateien f\u00fcr Java-Anwendungen und Dokumentformaten wie SVG und RSS. Die Ausf\u00fchrlichkeit des Formats erh\u00f6ht Dateigr\u00f6\u00dfe und Parsing-Zeit, bietet aber Flexibilit\u00e4t und Robustheit, die einige Branchen erfordern. XML ist besser, wenn Sie strikte Datenvalidierung, komplexe hierarchische Strukturen oder Kompatibilit\u00e4t mit Legacy-Enterprise-Systemen ben\u00f6tigen."
    },
    "s4": {
        "h": "YAML: Menschenlesbare Konfiguration",
        "p": "YAML verwendet eine einr\u00fcckungsbasierte Syntax ohne Klammern oder Tags und ist damit das lesbarste der drei Formate. Es unterst\u00fctzt Kommentare, mehrzeilige Strings und komplexe Datentypen. Beispiel: name: Hans\\nage: 30\\nactive: true. Die minimale Syntax reduziert visuelle Unordnung und verbessert die Lesbarkeit f\u00fcr Konfigurationsdateien.\n\nYAML ist eine Obermenge von JSON \u2013 jedes g\u00fcltige JSON ist auch g\u00fcltiges YAML \u2013 f\u00fcgt aber Funktionen wie Kommentare, Anker f\u00fcr referenzierte wiederholte Daten und flexiblere Zitierung hinzu. Es ist der Standard f\u00fcr Docker-Compose-Dateien, Kubernetes-Konfigurationen, Ansible-Playbooks und CI/CD-Pipelines (GitHub Actions, GitLab CI). YAMLs Abh\u00e4ngigkeit von Leerzeichen kann Probleme verursachen: Falsche Einr\u00fcckung bricht das Parsing, und das Mischen von Tabs und Leerzeichen erzeugt schwer zu debuggende Fehler. Obwohl hervorragend f\u00fcr manuelle Bearbeitung, sind YAML-Parser komplexer und langsamer als JSON-Parser. W\u00e4hlen Sie YAML, wenn menschliche Lesbarkeit und manuelle Bearbeitung Priorit\u00e4t haben, besonders f\u00fcr Konfigurationsdateien, die Entwickler h\u00e4ufig \u00e4ndern."
    },
    "s5": {
        "h": "Performance und Dateigr\u00f6\u00dfenvergleich",
        "p": "JSON bietet typischerweise die beste Performance mit den schnellsten Parsing-Geschwindigkeiten \u00fcber alle Programmiersprachen. Die einfache Syntax erfordert weniger Verarbeitungs-Overhead. JSON-Dateigr\u00f6\u00dfen sind moderat \u2013 kompakter als XML, aber etwas gr\u00f6\u00dfer als komprimiertes YAML. F\u00fcr einen Datensatz mit 1000 Datens\u00e4tzen k\u00f6nnte JSON 50KB, XML 80KB und YAML 45KB betragen.\n\nXML ist aufgrund der ausf\u00fchrlichen Syntax und komplexerer Parsing-Anforderungen am langsamsten zu parsen. DOM-basierte XML-Parser laden ganze Dokumente in den Speicher, was bei gro\u00dfen Dateien problematisch sein kann. SAX- und StAX-Parser bieten Streaming-Alternativen, erfordern aber komplexeren Code. XML-Dateigr\u00f6\u00dfen sind aufgrund \u00f6ffnender und schlie\u00dfender Tags am gr\u00f6\u00dften, obwohl Gzip-Komprimierung dies erheblich reduziert.\n\nYAML-Parsing ist aufgrund komplexerer Syntaxregeln und Typinferenz langsamer als JSON. YAML-Dateien sind jedoch in roher Form oft am kleinsten aufgrund minimaler Syntax-Overhead. F\u00fcr Hochleistungs-APIs mit Tausenden von Anfragen pro Sekunde ist JSON optimal. F\u00fcr Konfigurationsdateien, die einmal beim Start gelesen werden, ist YAMLs Parsing-Geschwindigkeit irrelevant. F\u00fcr gro\u00dfe Daten\u00fcbertragungen ber\u00fccksichtigen Sie Gzip-Komprimierung \u2013 sie reduziert Gr\u00f6\u00dfenunterschiede zwischen Formaten dramatisch."
    },
    "s6": {
        "h": "Das richtige Format w\u00e4hlen",
        "p": "Verwenden Sie JSON f\u00fcr REST-APIs, Webanwendungen, mobilen App-Datenaustausch und NoSQL-Datenbanken. W\u00e4hlen Sie JSON, wenn Sie schnelles Parsing, kompakte Gr\u00f6\u00dfe und breite Programmiersprachunterst\u00fctzung ben\u00f6tigen. Es ist ideal f\u00fcr Echtzeit-Datenaustausch und \u00fcberall, wo JavaScript beteiligt ist. JSON ist die Standardwahl f\u00fcr moderne Webentwicklung, es sei denn, Sie haben bestimmte Gr\u00fcnde f\u00fcr Alternativen.\n\nVerwenden Sie XML f\u00fcr Enterprise-Anwendungen, SOAP-Webservices, wenn Sie XML-Schema-Validierung ben\u00f6tigen oder mit Legacy-Systemen arbeiten. W\u00e4hlen Sie XML f\u00fcr dokumentenzentrierte Daten mit gemischtem Inhalt, komplexe Metadatenanforderungen oder wenn XSLT-Transformationen vorteilhaft sind. Branchen wie Finanzwesen, Gesundheitswesen und \u00f6ffentliche Verwaltung schreiben oft XML f\u00fcr Datenaustauschstandards vor.\n\nVerwenden Sie YAML f\u00fcr Konfigurationsdateien, Infrastructure as Code (Docker, Kubernetes), CI/CD-Pipelines und \u00fcberall, wo Menschen die Dateien h\u00e4ufig direkt bearbeiten. W\u00e4hlen Sie YAML, wenn Lesbarkeit und Kommentare wichtig sind und Parsing-Performance nicht kritisch ist. Vermeiden Sie YAML f\u00fcr gro\u00dfe Datens\u00e4tze oder hochfrequente API-Antworten, bei denen JSONs Performance-Vorteil z\u00e4hlt. F\u00fcr Projekte, die mehrere Formate ben\u00f6tigen, nutzen Sie Tuttilos Konverter, um zwischen JSON, XML und YAML zu transformieren und dabei die Datenstruktur beizubehalten."
    }
}

# 14. base64-encoding-guide
de["base64-encoding-guide"] = {
    "s1": {
        "h": "Was ist Base64-Codierung",
        "p": "Base64 ist ein Codierungsschema, das Bin\u00e4rdaten in ASCII-Text umwandelt und dabei nur 64 verschiedene Zeichen verwendet: A-Z, a-z, 0-9, + und /. Es handelt sich nicht um Verschl\u00fcsselung oder Komprimierung \u2013 es ist eine M\u00f6glichkeit, Bin\u00e4rdaten in einem Textformat darzustellen, das sicher durch textbasierte Systeme \u00fcbertragen werden kann.\n\nBase64 wurde geschaffen, um ein grundlegendes Problem zu l\u00f6sen: Viele Kommunikationsprotokolle und Datenformate wurden f\u00fcr Text konzipiert und k\u00f6nnen beliebige Bin\u00e4rdaten nicht zuverl\u00e4ssig verarbeiten. E-Mail-Systeme beispielsweise wurden f\u00fcr 7-Bit-ASCII-Text entwickelt und k\u00f6nnen Bin\u00e4rdateien besch\u00e4digen. Die Base64-Codierung stellt sicher, dass Bin\u00e4rdaten die \u00dcbertragung durch reine Textkan\u00e4le \u00fcberstehen, indem sie in einen universell sicheren Zeichensatz konvertiert werden. Der Name \u201eBase64\u201c stammt von der Verwendung von 64 verschiedenen Zeichen zur Datendarstellung, wobei jedes Zeichen 6 Bit Information codiert (2^6 = 64)."
    },
    "s2": {
        "h": "Wie Base64-Codierung funktioniert",
        "p": "Der Base64-Algorithmus verarbeitet Daten in Gruppen von drei Bytes (24 Bits) und wandelt sie in vier Base64-Zeichen um. Ein vereinfachtes Beispiel: Der Text \u201eMan\u201c in ASCII wird als drei Bytes dargestellt: M=77, a=97, n=110. In bin\u00e4r: 01001101 01100001 01101110.\n\nDiese 24 Bits werden in vier 6-Bit-Bl\u00f6cke umgruppiert: 010011, 010110, 000101, 101110. Jeder 6-Bit-Wert (0-63) wird auf ein Zeichen im Base64-Alphabet abgebildet. Die Werte 19, 22, 5, 46 entsprechen den Base64-Zeichen \u201eTWFu\u201c. Wenn Daten nicht perfekt durch drei Bytes teilbar sind, werden Padding-Zeichen (=) hinzugef\u00fcgt. Zum Beispiel w\u00fcrde die Codierung von \u201eMan!\u201c zu \u201eTWFuIQ==\u201c f\u00fchren, wobei die Gleichheitszeichen Padding anzeigen. Dies stellt sicher, dass die Ausgabel\u00e4nge immer ein Vielfaches von vier Zeichen ist, damit Decoder Daten in konsistenten Bl\u00f6cken verarbeiten k\u00f6nnen."
    },
    "s3": {
        "h": "H\u00e4ufige Anwendungsf\u00e4lle f\u00fcr Base64",
        "p": "Base64 ist unerl\u00e4sslich f\u00fcr das Einbetten von Bin\u00e4rdaten in Textformate. Data-URIs verwenden Base64, um Bilder direkt in HTML oder CSS einzubetten: data:image/png;base64,iVBORw0KG... Dies eliminiert separate HTTP-Anfragen f\u00fcr kleine Bilder und verbessert die Seitenladezeiten. E-Mail-Anh\u00e4nge verwenden Base64-Codierung, um Dateien \u00fcber SMTP zu \u00fcbertragen, das f\u00fcr reine Textnachrichten konzipiert wurde.\n\nWeb-APIs verwenden h\u00e4ufig Base64 zur \u00dcbertragung von Bin\u00e4rdaten in JSON, das nativ keine Bin\u00e4rtypen unterst\u00fctzt. Authentifizierungstoken, insbesondere JSON Web Tokens (JWT), verwenden Base64 zur Codierung von Header- und Payload-Daten. Das Speichern von Bin\u00e4rdaten in Datenbanken oder Konfigurationsdateien, die Text erwarten, erfordert oft Base64-Codierung. QR-Codes enthalten Base64-codierte Daten. Sogar CSS-Stylesheets betten kleine Bilder als Base64 ein, um HTTP-Anfragen zu reduzieren. Tools wie Tuttilos Base64-Encoder erleichtern das Codieren von Dateien, Text oder Bildern f\u00fcr diese verschiedenen Zwecke ohne Softwareinstallation."
    },
    "s4": {
        "h": "Auswirkungen auf die Dateigr\u00f6\u00dfe",
        "p": "Base64-Codierung erh\u00f6ht die Dateigr\u00f6\u00dfe um etwa 33%. Dieser Overhead entsteht durch die Darstellung von 3 Bytes Bin\u00e4rdaten mit 4 ASCII-Zeichen. Eine 100KB-Bin\u00e4rdatei wird bei Base64-Codierung ungef\u00e4hr 133KB gro\u00df. Diese Gr\u00f6\u00dfenzunahme ist der Hauptnachteil der Base64-Codierung.\n\nF\u00fcr kleine Dateien (einige Kilobyte) ist der Overhead akzeptabel und wird oft durch Komfortvorteile wie die Reduzierung von HTTP-Anfragen durch Data-URIs aufgewogen. F\u00fcr gro\u00dfe Dateien kann die 33%ige Zunahme erheblich sein, besonders f\u00fcr bandbreitenbeschr\u00e4nkte Anwendungen. Beim \u00dcbertragen gro\u00dfer Bin\u00e4rdateien ist direkte Bin\u00e4r\u00fcbertragung effizienter, wenn der Transportmechanismus dies unterst\u00fctzt.\n\nDie Gr\u00f6\u00dfenauswirkung ist besonders relevant f\u00fcr mobile Anwendungen mit begrenzten Datenverbindungen. Bedenken Sie, dass Base64-Codierung kombiniert mit Gzip-Komprimierung manchmal in kleineren Gesamttransfergr\u00f6\u00dfen als unkomprimierte Bin\u00e4rdaten resultieren kann, da ASCII-Text gut komprimiert. Moderne Bin\u00e4rprotokolle \u00fcbertreffen Base64 jedoch generell bei gro\u00dfen Payloads. Bewerten Sie, ob der Komfort der textbasierten Codierung den Gr\u00f6\u00dfen-Overhead f\u00fcr Ihren spezifischen Anwendungsfall rechtfertigt."
    },
    "s5": {
        "h": "Base64 codieren und decodieren",
        "p": "Die meisten Programmiersprachen enthalten integrierte Base64-Codierungs- und Decodierungsfunktionen. In JavaScript codiert btoa() Strings zu Base64 und atob() decodiert sie. Python verwendet das base64-Modul mit base64.b64encode() und base64.b64decode(). Befehlszeilentools wie base64 auf Unix-Systemen und certutil unter Windows bieten Codierungsm\u00f6glichkeiten.\n\nWebbasierte Tools wie die auf Tuttilo bieten Codierung ohne Programmierkenntnisse. F\u00fcgen Sie einfach Text ein oder laden Sie eine Datei hoch, um die Base64-Darstellung zu erhalten. Diese Tools handhaben sowohl Codierung als auch Decodierung, oft mit Optionen f\u00fcr verschiedene Zeichens\u00e4tze und Varianten wie URL-sicheres Base64 (das + und / durch - und _ ersetzt, um Probleme in URLs zu vermeiden).\n\nBei der Implementierung von Base64 achten Sie auf Zeichencodierungsprobleme. Der Zeichensatz der Eingabedaten (UTF-8, ASCII usw.) muss zwischen Codierung und Decodierung konsistent sein. F\u00fcr Dateicodierung stellen Sie sicher, dass der Bin\u00e4rmodus verwendet wird, um Zeilenende-Konvertierungen zu verhindern, die die Daten besch\u00e4digen. Validieren Sie immer die decodierte Ausgabe, da fehlerhaft formatierte Base64-Strings in manchen Implementierungen unleserliche Daten erzeugen oder unbemerkt fehlschlagen k\u00f6nnen."
    },
    "s6": {
        "h": "Base64-Varianten und Sicherheits\u00fcberlegungen",
        "p": "Es existieren mehrere Base64-Varianten f\u00fcr bestimmte Zwecke. Standard-Base64 verwendet +, / und = Zeichen. URL-sicheres Base64 (Base64url) ersetzt + durch - und / durch _ und l\u00e4sst Padding (=) weg, um Probleme zu vermeiden, wenn Base64-Strings in URLs oder Dateinamen erscheinen. MIME-Base64 f\u00fcgt alle 76 Zeichen Zeilenumbr\u00fcche f\u00fcr E-Mail-Kompatibilit\u00e4t hinzu.\n\nBase64 ist keine Verschl\u00fcsselung und bietet keine Sicherheit. Codierte Daten sind trivial von jedem decodierbar \u2013 es ist vergleichbar mit einer einfachen Substitutions-Chiffre. Verwenden Sie Base64 niemals allein zum Schutz sensibler Informationen. Wenn Sie Passw\u00f6rter oder API-Schl\u00fcssel Base64-codiert im Code sehen, sind sie nicht sicher. Base64 dient der Codierung, nicht der Sicherheit.\n\nAllerdings wird Base64 h\u00e4ufig mit echter Verschl\u00fcsselung kombiniert. Zum Beispiel werden verschl\u00fcsselte Daten oft Base64-codiert f\u00fcr die \u00dcbertragung, und kryptografische Signaturen werden f\u00fcr textbasierte Formate Base64-codiert. JWT-Token verwenden Base64url-Codierung f\u00fcr ihre Komponenten, st\u00fctzen sich aber f\u00fcr die Sicherheit auf Signaturen, nicht auf die Codierung selbst. Wenn Sie Sicherheit ben\u00f6tigen, verwenden Sie echte Verschl\u00fcsselungsalgorithmen wie AES oder RSA, und codieren Sie die verschl\u00fcsselte Ausgabe optional f\u00fcr die \u00dcbertragung als Base64. Das Verst\u00e4ndnis dieser Unterscheidung verhindert h\u00e4ufige Sicherheitsfehler, bei denen Entwickler f\u00e4lschlicherweise glauben, Base64-Codierung sch\u00fctze Daten."
    }
}

# 15. image-optimization-web
de["image-optimization-web"] = {
    "s1": {
        "h": "Warum Bildoptimierung wichtig ist",
        "p": "Bilder machen typischerweise 50-70% der gesamten Webseitengr\u00f6\u00dfe aus und sind damit die gr\u00f6\u00dfte Chance f\u00fcr Performance-Verbesserungen. Nicht optimierte Bilder verlangsamen Seitenladezeiten, erh\u00f6hen Absprungraten und schaden SEO-Rankings. Googles Core Web Vitals messen speziell die Ladeleistung, und Bilder beeinflussen direkt den Largest Contentful Paint (LCP), eine der Schl\u00fcsselmetriken.\n\nSeitengeschwindigkeit beeinflusst Nutzererfahrung und Konversionen. Studien zeigen, dass 53% der mobilen Nutzer Seiten verlassen, die l\u00e4nger als 3 Sekunden zum Laden brauchen. F\u00fcr E-Commerce kann jede Sekunde Verz\u00f6gerung die Konversionen um 7% reduzieren. \u00dcber die Nutzererfahrung hinaus verbrauchen langsame Seiten mehr Bandbreite, was sowohl f\u00fcr Sie als auch f\u00fcr Ihre Nutzer Kosten verursacht, besonders bei mobilen Datentarifen. Suchmaschinen priorisieren auch schnell ladende Seiten in Rankings. Richtige Bildoptimierung kann das Gesamtgewicht der Seite um 50-80% reduzieren und dabei Performance-Metriken, Nutzerzufriedenheit und Suchsichtbarkeit dramatisch verbessern, ohne die visuelle Qualit\u00e4t zu opfern."
    },
    "s2": {
        "h": "Das richtige Bildformat w\u00e4hlen",
        "p": "Die Formatwahl ist das Fundament der Bildoptimierung. JPEG eignet sich am besten f\u00fcr Fotografien und komplexe Bilder mit vielen Farben und Verl\u00e4ufen. Verwenden Sie Qualit\u00e4tseinstellungen von 70-85% f\u00fcr optimale Balance zwischen Gr\u00f6\u00dfe und Qualit\u00e4t. PNG ist ideal f\u00fcr Grafiken mit Transparenz, Logos, Screenshots und Bilder mit Text oder scharfen Kanten, bei denen verlustfreie Komprimierung ben\u00f6tigt wird.\n\nWebP bietet \u00fcberlegene Komprimierung f\u00fcr sowohl Fotografien als auch Grafiken und liefert 25-35% kleinere Dateigr\u00f6\u00dfen als JPEG bei gleicher Qualit\u00e4t. Es unterst\u00fctzt Transparenz wie PNG und wird jetzt von \u00fcber 95% der Browser unterst\u00fctzt. AVIF ist das neueste Format und bietet noch bessere Komprimierung als WebP, aber die Browser-Unterst\u00fctzung w\u00e4chst noch. F\u00fcr Icons und einfache Grafiken ziehen Sie SVG in Betracht \u2013 ein Vektorformat, das perfekt skaliert und oft die kleinsten Dateigr\u00f6\u00dfen erzeugt.\n\nF\u00fcr maximale Kompatibilit\u00e4t und Performance verwenden Sie das HTML-Picture-Element mit mehreren Formaten: Liefern Sie AVIF f\u00fcr moderne Browser, fallen Sie auf WebP f\u00fcr etwas \u00e4ltere Browser zur\u00fcck und bieten Sie JPEG oder PNG als letzten Fallback. So erh\u00e4lt jeder das beste Format, das sein Browser unterst\u00fctzt. Tuttilos Bildkonverter erleichtert das Erstellen mehrerer Formatversionen zum Vergleich und Deployment."
    },
    "s3": {
        "h": "Komprimierungstechniken und Tools",
        "p": "Komprimierung reduziert die Dateigr\u00f6\u00dfe bei akzeptabler visueller Qualit\u00e4t. Verlustbehaftete Komprimierung (JPEG, WebP) verwirft dauerhaft einige Bilddaten, w\u00e4hrend verlustfreie Komprimierung (PNG, verlustfreies WebP) alle Originaldaten bewahrt, aber geringere Gr\u00f6\u00dfenreduzierungen erzielt.\n\nF\u00fcr JPEG liefern Qualit\u00e4tseinstellungen von 70-85 hervorragende Ergebnisse. Unter 70 erscheinen sichtbare Artefakte; \u00fcber 85 nimmt die Dateigr\u00f6\u00dfe deutlich zu bei minimalem Qualit\u00e4tsgewinn. Verwenden Sie Tools wie ImageOptim, Squoosh oder Tuttilos Bildkompressor, um verschiedene Qualit\u00e4tsstufen zu testen und Ergebnisse visuell zu vergleichen. F\u00fcr PNG k\u00f6nnen Tools wie pngquant die Farbtiefe reduzieren und dabei die visuelle Qualit\u00e4t beibehalten, wobei oft 50-70% Gr\u00f6\u00dfenreduzierung erreicht wird.\n\nErw\u00e4gen Sie Zwei-Stufen-Optimierung: Zuerst Bilder auf ihre Anzeigegr\u00f6\u00dfe verkleinern (nie ein 3000px-Bild liefern, wenn es mit 500px angezeigt wird), dann Komprimierung anwenden. Automatisierte Build-Tools wie imagemin k\u00f6nnen Bilder w\u00e4hrend des Deployments optimieren. F\u00fcr Stapelverarbeitung bieten Befehlszeilentools wie ImageMagick oder cwebp skriptbare Optimierung. Bewahren Sie immer hochaufl\u00f6sende Originaldateien auf und generieren Sie optimierte Versionen, statt wiederholt dieselben Dateien zu komprimieren, was die Qualit\u00e4t bei jedem Durchgang verschlechtert."
    },
    "s4": {
        "h": "Responsive Bilder und Gr\u00f6\u00dfenanpassung",
        "p": "Responsive Bilder liefern verschiedene Gr\u00f6\u00dfen basierend auf dem Bildschirm und Viewport des Nutzers. Das HTML-srcset-Attribut l\u00e4sst Browser geeignete Bildgr\u00f6\u00dfen ausw\u00e4hlen: <img src=\"small.jpg\" srcset=\"small.jpg 500w, medium.jpg 1000w, large.jpg 2000w\" sizes=\"(max-width: 600px) 500px, 1000px\">. Browser laden nur die ben\u00f6tigte Gr\u00f6\u00dfe herunter und sparen Bandbreite.\n\nErstellen Sie Bilder in 2-4 verschiedenen Gr\u00f6\u00dfen, um Mobile (320-480px), Tablet (768-1024px) und Desktop (1200-1920px) Viewports abzudecken. F\u00fcr hochaufl\u00f6sende Displays (Retina) liefern Sie Bilder in 2x-Aufl\u00f6sung f\u00fcr gestochen scharfe Darstellung. Allerdings bemerken die meisten Nutzer bei Fotografien keine Qualit\u00e4tsunterschiede \u00fcber 1,5x hinaus, also w\u00e4gen Sie Dateigr\u00f6\u00dfe gegen abnehmenden Ertrag ab.\n\nVerwenden Sie das sizes-Attribut, um Browsern mitzuteilen, wie breit das Bild bei verschiedenen Breakpoints angezeigt wird. Dies erm\u00f6glicht Browsern die optimale Bildauswahl, bevor CSS geladen wird. F\u00fcr Art Direction \u2013 das Liefern verschiedener Ausschnitte oder Seitenverh\u00e4ltnisse auf verschiedenen Bildschirmen \u2013 verwenden Sie das Picture-Element mit mehreren Source-Elementen und Media Queries. Dies stellt sicher, dass wichtige Bildbereiche unabh\u00e4ngig von der Viewport-Gr\u00f6\u00dfe sichtbar bleiben."
    },
    "s5": {
        "h": "Lazy Loading und Progressive Enhancement",
        "p": "Lazy Loading verz\u00f6gert das Laden von Bildern, bis sie ben\u00f6tigt werden, und verbessert die anf\u00e4ngliche Seitenladezeit dramatisch. Moderne Browser unterst\u00fctzen natives Lazy Loading mit dem loading=\"lazy\"-Attribut: <img src=\"image.jpg\" loading=\"lazy\">. Dies verz\u00f6gert das Laden von Bildern unterhalb des sichtbaren Bereichs, bis Nutzer in deren N\u00e4he scrollen, reduziert den anf\u00e4nglichen Bandbreitenverbrauch und beschleunigt den First Contentful Paint.\n\nWenden Sie Lazy Loading auf Bilder unterhalb des sichtbaren Bereichs an, aber nicht auf Heldenbilder oder Inhalte, die beim Seitenaufruf sichtbar sind, da deren verz\u00f6gertes Laden sp\u00fcrbare Verz\u00f6gerungen verursacht. F\u00fcr kritische Bilder im sichtbaren Bereich verwenden Sie loading=\"eager\" oder lassen das Attribut weg. Erw\u00e4gen Sie die Verwendung eines leichtgewichtigen Platzhalters oder eines niedrigaufl\u00f6senden Bildplatzhalters (LQIP), der sofort l\u00e4dt, w\u00e4hrend das Bild in voller Qualit\u00e4t lazy geladen wird.\n\nProgressive JPEGs laden in mehreren Durchg\u00e4ngen und zeigen zun\u00e4chst eine niedrigqualitative Version, die sich progressiv sch\u00e4rft, w\u00e4hrend mehr Daten eintreffen. Dies verbessert die wahrgenommene Performance, indem sofort etwas angezeigt wird, statt leere Bereiche zu hinterlassen. F\u00fcr zus\u00e4tzliche Performance implementieren Sie die Blur-up-Technik: Zeigen Sie eine winzige, unscharfe Version (< 1KB), w\u00e4hrend das volle Bild l\u00e4dt, und bieten Sie visuellen Kontext ohne Verz\u00f6gerung. Bibliotheken wie lazysizes bieten erweiterte Lazy-Loading-Funktionen einschlie\u00dflich responsiver Bilder und automatischer srcset-Generierung f\u00fcr \u00e4ltere Browser ohne native Unterst\u00fctzung."
    },
    "s6": {
        "h": "Content Delivery und Caching-Strategien",
        "p": "Content Delivery Networks (CDNs) verteilen Bilder \u00fcber globale Server und reduzieren die Latenz, indem Bilder von Standorten in der N\u00e4he der Nutzer bereitgestellt werden. CDNs wie Cloudflare, Cloudinary und imgix bieten Bildoptimierungsfunktionen einschlie\u00dflich automatischer Formatkonvertierung, Gr\u00f6\u00dfen\u00e4nderung und Komprimierung. Sie k\u00f6nnen Nutzerbrowser erkennen und automatisch WebP an Chrome oder AVIF an die neueste Firefox-Version liefern.\n\nImplementieren Sie geeignete Caching-Header, um sicherzustellen, dass Browser Bilder lokal speichern, statt sie bei wiederholten Besuchen erneut herunterzuladen. Setzen Sie Cache-Control-Header mit langen Ablaufzeiten (1 Jahr) f\u00fcr Bilder, die sich nicht \u00e4ndern. Verwenden Sie versionierte Dateinamen (image-v2.jpg) oder Query-Strings (image.jpg?v=2), wenn Bilder aktualisiert werden, um den Cache zu umgehen. Diese Kombination aus langen Cache-Zeiten und versionierten Namen bietet optimale Performance.\n\nF\u00fcr dynamische Bilder erw\u00e4gen Sie On-the-fly-Optimierungsdienste, die Bilder automatisch basierend auf Anfrageparametern in Gr\u00f6\u00dfe anpassen und komprimieren. Dies eliminiert die manuelle Bildverarbeitung f\u00fcr verschiedene Gr\u00f6\u00dfen. Aktivieren Sie HTTP/2 oder HTTP/3 auf Ihrem Server f\u00fcr multiplextes Bildladen, das mehrere Bilder gleichzeitig \u00fcber eine einzige Verbindung effizienter l\u00e4dt als HTTP/1.1. F\u00fcr die ultimative Performance kombinieren Sie alle diese Techniken: CDN-Bereitstellung, moderne Formate mit Fallbacks, Lazy Loading, responsive Bilder, Komprimierung und Caching. Tools wie Lighthouse \u00fcberpr\u00fcfen diese Optimierungen und liefern umsetzbare Empfehlungen zur Verbesserung."
    }
}

# 16. file-security-privacy
de["file-security-privacy"] = {
    "s1": {
        "h": "Warum Dateisicherheit wichtiger denn je ist",
        "p": "Im Jahr 2026 bearbeiten wir mehr sensible digitale Dateien als je zuvor \u2013 von Steuerdokumenten und medizinischen Unterlagen \u00fcber Gesch\u00e4ftsvertr\u00e4ge bis hin zu pers\u00f6nlichen Fotos. Jedes Mal, wenn Sie eine Datei in ein Online-Tool hochladen, setzen Sie m\u00f6glicherweise private Daten gegen\u00fcber Dritten frei. Dateisicherheit zu verstehen ist nicht nur f\u00fcr Technikexperten wichtig; es ist unerl\u00e4sslich f\u00fcr jeden, der seine Privatsph\u00e4re sch\u00e4tzt.\n\nDie Folgen eines Datenlecks k\u00f6nnen schwerwiegend sein: Identit\u00e4tsdiebstahl, finanzieller Betrug, geleakte vertrauliche Informationen oder kompromittierte Gesch\u00e4ftsgeheimnisse. Dennoch laden viele Nutzer unwissentlich sensible Dateien auf Server hoch, \u00fcber die sie nichts wissen, und vertrauen darauf, dass ihre Daten verantwortungsvoll behandelt werden. Die Realit\u00e4t ist: Sobald Ihre Datei Ihr Ger\u00e4t verl\u00e4sst, verlieren Sie die Kontrolle dar\u00fcber."
    },
    "s2": {
        "h": "Die versteckten Risiken serverbasierter Dateiverarbeitung",
        "p": "Traditionelle Online-Tools erfordern das Hochladen von Dateien auf Remote-Server zur Verarbeitung. Dies erzeugt mehrere Sicherheitsl\u00fccken. Erstens reist Ihre Datei \u00fcber das Internet und k\u00f6nnte w\u00e4hrend der \u00dcbertragung abgefangen werden. Zweitens speichert der Server Ihre Datei vor\u00fcbergehend \u2013 oder manchmal dauerhaft \u2013 und schafft ein Ziel f\u00fcr Hacker. Drittens k\u00f6nnte das betreibende Unternehmen Ihre Daten f\u00fcr Werbung analysieren, an Dritte verkaufen oder rechtlich zur Herausgabe an Beh\u00f6rden gezwungen werden.\n\nSelbst renommierte Unternehmen erleben Sicherheitsverletzungen. In den letzten Jahren haben gro\u00dfe Cloud-Dienste Datenlecks erfahren, die Millionen von Nutzern betrafen. Kleinere, weniger bekannte Online-Tool-Websites haben oft noch schw\u00e4chere Sicherheitsma\u00dfnahmen. Viele verschl\u00fcsseln Dateien nicht im Ruhezustand, verf\u00fcgen \u00fcber keine angemessenen Zugriffskontrollen oder bewahren Dateien auf ihren Servern weit l\u00e4nger als n\u00f6tig auf. Einige kostenlose Tools monetarisieren, indem sie hochgeladene Inhalte analysieren und Dokumente lesen, um gezielte Werbung zu schalten oder Nutzerprofile zu erstellen."
    },
    "s3": {
        "h": "Wie browserbasierte Tools Ihre Privatsph\u00e4re sch\u00fctzen",
        "p": "Browserbasierte Tools wie die auf Tuttilo repr\u00e4sentieren einen grundlegenden Wandel in der Online-Sicherheit. Diese Tools verarbeiten Dateien vollst\u00e4ndig in Ihrem Webbrowser mithilfe von clientseitigem JavaScript und WebAssembly. Ihre Datei verl\u00e4sst nie Ihr Ger\u00e4t \u2013 es gibt keinen Upload, keine Serverspeicherung, keine \u00dcbertragung \u00fcber das Internet. Die Verarbeitung erfolgt lokal auf Ihrem Computer oder Telefon, genau wie bei Desktop-Software.\n\nDiese Architektur bietet mehrere kritische Sicherheitsvorteile. Erstens gibt es keine Netzwerk\u00fcbertragung zum Abfangen. Zweitens gibt es keinen Serverspeicher, der gehackt oder geleakt werden kann. Drittens hat der Tool-Anbieter nie Zugriff auf Ihre Dateien \u2013 er kann Ihre Daten nicht lesen, analysieren oder monetarisieren, weil er sie nie erh\u00e4lt. Viertens behalten Sie die vollst\u00e4ndige Kontrolle: Dateien werden im tempor\u00e4ren Browser-Speicher verarbeitet und sofort gel\u00f6scht, wenn Sie den Tab schlie\u00dfen oder die Seite verlassen."
    },
    "s4": {
        "h": "Verschl\u00fcsselung und Datenschutz verstehen",
        "p": "Verschl\u00fcsselung ist der Prozess der Codierung von Informationen, sodass nur autorisierte Parteien sie lesen k\u00f6nnen. Wenn Tools behaupten, Verschl\u00fcsselung zu verwenden, ist es wichtig zu verstehen, welche Art. Transportverschl\u00fcsselung (HTTPS/SSL) sch\u00fctzt Daten w\u00e4hrend der \u00dcbertragung \u00fcber das Internet, aber sobald sie den Server erreichen, werden sie typischerweise zur Verarbeitung entschl\u00fcsselt. Ende-zu-Ende-Verschl\u00fcsselung h\u00e4lt Daten w\u00e4hrend der gesamten Reise verschl\u00fcsselt, aber viele Online-Tools implementieren sie nicht ordnungsgem\u00e4\u00df.\n\nDer st\u00e4rkste Schutz ist die Zero-Knowledge-Architektur: Der Dienstanbieter hat null Wissen \u00fcber Ihre Daten, weil sie ihn nie erreichen. Genau das bieten browserbasierte Tools. Tuttilos Tools verwenden Zero-Knowledge-Verarbeitung von Haus aus \u2013 Ihre Dateien werden nie an Server \u00fcbertragen, daher wird die Verschl\u00fcsselung von Uploads unn\u00f6tig. Die Dateiverarbeitung erfolgt in der Sandbox-Umgebung Ihres Browsers, isoliert von anderen Websites und gesch\u00fctzt durch die integrierten Sicherheitsfunktionen Ihres Browsers."
    },
    "s5": {
        "h": "Wie Tuttilo Ihre Dateien privat h\u00e4lt",
        "p": "Tuttilo basiert auf einer Privatsph\u00e4re-zuerst-Philosophie. Jedes Tool \u2013 von PDF-Editoren \u00fcber Bildkonverter bis hin zu Datenanalysatoren \u2013 l\u00e4uft vollst\u00e4ndig in Ihrem Browser mithilfe moderner Webtechnologien wie WebAssembly. Wenn Sie eine Datei ausw\u00e4hlen, wird sie in den tempor\u00e4ren Speicher Ihres Browsers geladen, gem\u00e4\u00df der gew\u00e4hlten Operation verarbeitet, und das Ergebnis wird lokal generiert. Zu keinem Zeitpunkt wird Ihre Datei auf Tuttilos Server oder einen Drittanbieterdienst hochgeladen.\n\nDieser Ansatz bietet mehrere Garantien: keine Dateispeicherung auf externen Servern, keine Daten\u00fcbertragung \u00fcber das Internet, keine Analyse oder Nachverfolgung von Dateiinhalten und keine M\u00f6glichkeit serverseitiger Sicherheitsverletzungen, die Ihre Dateien betreffen. Tuttilos Server liefern nur den Code des Tools an Ihren Browser; sie empfangen oder verarbeiten nie Ihre tats\u00e4chlichen Dateien. Zus\u00e4tzlich erfordert Tuttilo f\u00fcr die meisten Tools keine Kontoerstellung oder Anmeldung, was ein weiteres potenzielles Privatsph\u00e4rerisiko eliminiert. Sie k\u00f6nnen die Tools anonym verwenden, und sobald Sie Ihren Browser-Tab schlie\u00dfen, werden alle Spuren Ihrer Datei aus dem Speicher entfernt."
    },
    "s6": {
        "h": "Best Practices f\u00fcr Online-Dateisicherheit",
        "p": "Auch bei browserbasierten Tools ist das Befolgen von Sicherheits-Best-Practices wichtig. Erstens verwenden Sie immer HTTPS-Websites \u2013 achten Sie auf das Schloss-Symbol in Ihrer Adressleiste. Zweitens vermeiden Sie die Verwendung von Online-Tools f\u00fcr hochsensible Dokumente, es sei denn, sie verwenden ausdr\u00fccklich clientseitige Verarbeitung. Drittens lesen Sie Datenschutzrichtlinien, um zu verstehen, was mit Ihren Daten geschieht. Viertens nutzen Sie Browser-Privatsph\u00e4refunktionen wie den privaten/Inkognito-Modus f\u00fcr zus\u00e4tzlichen Schutz, der verhindert, dass Dateien auf Ihrem Ger\u00e4t zwischengespeichert werden.\n\nBei der Wahl von Online-Tools priorisieren Sie solche, die Dateien lokal in Ihrem Browser verarbeiten. Achten Sie auf klare Aussagen \u00fcber clientseitige Verarbeitung und Zero-Knowledge-Architektur. Seien Sie skeptisch gegen\u00fcber Tools, die Privatsph\u00e4re versprechen, aber dennoch Datei-Uploads erfordern \u2013 wenn eine Datei hochgeladen wird, ist sie nicht mehr wirklich privat. Halten Sie schlie\u00dflich Ihren Browser aktuell, um sicherzustellen, dass Sie die neuesten Sicherheitspatches haben. Moderne Browser wie Chrome, Firefox, Safari und Edge enthalten ausgefeilte Sandboxing- und Sicherheitsfunktionen, die Sie bei der Verwendung webbasierter Tools wie Tuttilo sch\u00fctzen."
    }
}

with open('/tmp/de_blog_part4.json', 'w', encoding='utf-8') as f:
    json.dump(de, f, ensure_ascii=False)
print(f"Part 4: {len(de)} articles total")
